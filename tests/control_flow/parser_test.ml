open OUnit2
open Pseudo_lib.Ast

(* Function to parse an expression into an AST *)
let parse_expression stmt =
  let lexbuf = Lexing.from_string stmt in
  Pseudo_lib.Parser.program Pseudo_lib.Lexer.token lexbuf

(* Expected AST for "if (2 < 3) then 4 else 5" *)
let expected_ast_if = 
  Cstmt (Sif (Ebinop (Blt, Ecst (Cint 2, None), Ecst (Cint 3, None), None), 
              Seval (Ecst (Cint 4, None)), 
              Seval (Ecst (Cint 5, None))))

(* OUnit test *)
let test_parse_expression _ =
  assert_equal (parse_expression 
  "if 2 < 3 {
    4 
  } else {
    5
  }") expected_ast_if

(* Function to parse a statement into an AST *)
let parse_statement stmt =
  let lexbuf = Lexing.from_string stmt in
  Pseudo_lib.Parser.program Pseudo_lib.Lexer.token lexbuf

(* Lexing.position * Lexing.position as a default value equal ident "i" in the input*)
let position = {
  Lexing.pos_fname = "";
  Lexing.pos_lnum = 1;
  Lexing.pos_bol = 0;
  Lexing.pos_cnum = 4;
}, {
  Lexing.pos_fname = "";
  Lexing.pos_lnum = 1;
  Lexing.pos_bol = 0;
  Lexing.pos_cnum = 5;
}

(* Function to convert an AST into a string *)
(* Expected AST for "if (2 < 3) then 4 else 5" *)
let expected_ast_for = 
  Cstmt (
    Sfor ({ loc = position; id = "i"; typ = None }, 
    Ecst(Cint 1, None), Ecst(Cint 10, None), Sblock [Sprint(Ecst(Cstring "\"hello\"", None)); 
    Sprint(Ecst(Cstring "\"hello\"", None))], 1)
  ) 

(* OUnit test for for-loops*)
let test_for_loop_statement _ =
  let parsed_ast = parse_statement "for i = 1 to 10 { 
    print(\"hello\") 
    print(\"hello\") 
  }" in
  assert_equal (parsed_ast) expected_ast_for

(* Function to parse an expression into an AST *)
let parse_expression stmt =
  let lexbuf = Lexing.from_string stmt in
  Pseudo_lib.Parser.program Pseudo_lib.Lexer.token lexbuf

(* Expected AST for "if (2 < 3) then 4 else 5" *)
let expected_ast_while = 
  Cstmt (Swhile (Ebinop (Blt, Ecst (Cint 2, None), Ecst (Cint 3, None), None), 
              Sblock (Sprint (Ecst (Cint 1, None)) :: [Scontinue])))

(* OUnit test for while statement *)
let test_while_statement _ =
  assert_equal (parse_expression 
  "while 2 < 3 {
    print(1)
    continue
  }") expected_ast_while

(* Test suite *)

(* Function to parse an expression into an AST *)
let parse_expression stmt =
  let lexbuf = Lexing.from_string stmt in
  Pseudo_lib.Parser.program Pseudo_lib.Lexer.token lexbuf

(* Expected AST for "if (2 < 3) then 4 else 5" *)
let expected_ast_repeat = 
  Cstmt (Srepeat (Ecst(Cint 1, None), 
        Sblock (Sprint (Ecst (Cint 1, None)) :: [Seval(Ebinop(Badd, Ecst(Cint 1, None), Ecst(Cint 1, None), None))])))

(* OUnit test for while statement *)
let test_repeat_statement _ =
  assert_equal (parse_expression 
  "repeat {
    print(1)
    1 + 1
  } until 1") expected_ast_repeat

let suite =
  "Control Flow Parser Suite" >::: [
      "test_parse_control_flow_expression" >:: test_parse_expression;
      "test_for_loop_statement" >:: test_for_loop_statement;
      "test_while_statement" >:: test_while_statement;
      "test_repeat_statement" >:: test_repeat_statement;
    ]

(*
  This test checks if the AST generated by the function parse_expression for 
  the string "if (2 < 3) then 4 else 5" is equal to the expected AST. We utilize 
  both the parser and lexer to generate the AST. We should probably test the 
  parser and lexer separately, but for now, we will test them together. The AST 
  generated by parse_expression for "if (2 < 3) then 4 else 5" is equal to 
  expected_ast because it represents the correct control flow structure.
*)
