(* Parser takes sequence of tokens as input (generated by Lexer) and determines if it conforms to the syntax rules defined by the grammar (CFG). *)
%{
  open Ast
%}

(* Menhir parser generator library and generates an OCaml module. *)
%token EOF
%token ADD SUB DIV MUL MOD
%token AND OR EQUAL NOTEQUAL LESS LESSEQUAL GREATER GREATEREQUAL
%token <int> INT
%token <string> ID
%token <float> FLOAT
%token <string> STRING COMMENT
%token LPAREN RPAREN LBRACE RBRACE COMMA DOT
%token LBRACKET RBRACKET
%token ASSIGN
%token NEWLINE
%token LET BE A NEW
%token IF ELSEIF ELSE PRINT FOR TO DOWNTO WHILE DO REPEAT UNTIL
%token BREAK CONTINUE
%token RETURN
%token SORT
%token EXCHANGE WITH
%token RANDOM
%token NIL
%token INFINITY
%token ERROR

(* Type declarations tell the parser what type of value to produce for each non-terminal symbol in the grammar. *)
%start program
%type <Ast.command> program
%type <Ast.stmt> stmt suite conditional iterative collections methods jump_stmt
%type <Ast.expr> expr simple_expr
%type <Ast.expr list> expr_list
%type <Ast.constant> constant
%type <Ast.ident> ident

(* Precedence and associativity declarations. Lines beneath has higher precedence level. *)
%left NEWLINE
%left ADD SUB
%left MUL DIV MOD
%left AND OR 
%left EQUAL NOTEQUAL LESS LESSEQUAL GREATER GREATEREQUAL
%left DOT

%% (* The separator marks the end of the declarations section and the beginning of the rules section. *)

program:
  | s = suite EOF { Cstmt s }
;

suite:
  | s = stmt { s }
  | NEWLINE s = suite { s }
  | s = stmt NEWLINE s1 = suite { Sblock [s; s1] }
;

stmt:
  | c = COMMENT { Scomment(c) }
  | e1 = expr ASSIGN e2 = expr { Sassign(e1, e2)}
  | PRINT LPAREN e = expr RPAREN { Sprint(e) }
  | e1 = expr { Seval(e1) }
  | s = stmt NEWLINE { s }
  | c = collections { c }
  | c = conditional { c }
  | i = iterative { i }
  | j = jump_stmt { j }
  | m = methods { m }
;

jump_stmt:
  | RETURN e = expr { Sreturn(e) }
  | BREAK { Sbreak }
  | CONTINUE { Scontinue }
  | ERROR s = STRING { Serror(s) }
;

methods:
  | SORT id = ident { Ssort(id)}
  | EXCHANGE e1 = expr WITH e2 = expr { Sexchange(e1, e2) } (* The rule can be read as follows: When the parser encounters the EXCHANGE token, it expects to find an identifier (represented by id1 = ident). Then it expects the WITH token, followed by another identifier (id2 = ident). *)
  | RANDOM LPAREN e = expr RPAREN { Srandom(e)}
;

conditional:
  | IF e = expr LBRACE s = suite RBRACE { Sif(e, s, Sblock []) }
  | IF e = expr LBRACE s = suite RBRACE ELSE LBRACE s1 = suite RBRACE { Sif(e, s, s1) }
  | IF e = expr LBRACE s = suite RBRACE ELSEIF e1 = expr LBRACE s1 = suite RBRACE { Sif(e, s, Sif(e1, s1, Sblock [])) }
  | IF e = expr LBRACE s = suite RBRACE ELSEIF e1 = expr LBRACE s1 = suite RBRACE ELSE LBRACE s2 = suite RBRACE { Sif(e, s, Sif(e1, s1, s2)) }
;

iterative:
  | FOR id = ident ASSIGN e1 = expr TO e2 = expr LBRACE s = suite RBRACE { Sfor(id, e1, e2, s, 1) }
  | FOR id = ident ASSIGN e1 = expr DOWNTO e2 = expr LBRACE s = suite RBRACE { Sfor(id, e1, e2, s, -1) }
  | WHILE e = expr LBRACE s = suite RBRACE { Swhile(e, s) }
  | WHILE e = expr DO LBRACE s = suite RBRACE { Sdowhile(e, s) }
  | REPEAT LBRACE s = suite RBRACE UNTIL e = expr { Srepeat(e, s) }
;

collections:
  | id = ident LPAREN p = expr_list RPAREN LBRACE s = suite RBRACE { Sdef(id, p, s) }
  | LET id = ident BE A NEW list = ident { Snewlist(id, Ecst(Cnil), list) }
  | LET id = ident LBRACKET RBRACKET BE A NEW list = ident { Snewlist(id, Ecst(Cnil), list) }
  | LET id = ident LBRACKET e1 = expr RBRACKET BE A NEW list = ident { Snewlist(id, e1, list) }
;

expr_list:
  | /* empty */ { [] }
  | e = expr { [e] }
  | e = expr COMMA el = expr_list { e :: el }
;

expr:
  | e1 = expr o = binop e2 = expr { Ebinop(o, e1, e2) }
  | LPAREN e1 = expr COMMA el = expr_list RPAREN { Etuple(e1 :: el) }
  | id = ident LPAREN p = expr_list RPAREN { Ecall(id, p)}
  | e1 = expr DOT e2 = ident { Eattribute(e1, e2) }
  | LBRACKET e = expr_list RBRACKET { Elist(e) }
  | id = ident LBRACKET e = expr RBRACKET { Eget(id, e) }
  | s = simple_expr { s }
;

simple_expr:
  | u = unop e = expr { Eunop(u, e) }
  | LPAREN e = expr RPAREN { e }
  | e1 = ident { Eident(e1) }
  | c = constant { Ecst(c) }
;

constant:
  | c = INT { Cint(c) }
  | c = FLOAT { Cfloat(c) }
  | c = STRING { Cstring(c) }
  | NIL { Cnil }
  | INFINITY { Cinfinity }

ident:
  id = ID { { loc = ($startpos, $endpos); id } }
;

%inline binop:
  | ADD { Badd }
  | SUB { Bsub }
  | DIV { Bdiv }
  | MUL { Bmul }
  | MOD { Bmod }
  | AND { Band }
  | OR { Bor }
  | EQUAL { Beq }
  | NOTEQUAL { Bneq }
  | LESS { Blt }
  | LESSEQUAL { Ble }
  | GREATER { Bgt }
  | GREATEREQUAL { Bge }
;

%inline unop:
  | ADD { Uplus }
  | SUB { Uneg }
